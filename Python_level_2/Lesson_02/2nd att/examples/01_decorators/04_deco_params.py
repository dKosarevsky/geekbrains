
# -------------- Декораторы с параметрами. Рекурсия ---------------------------

# Декораторы могут принимать параметры. В этом случае говорят о "фабрике декораторов".
# Для того, чтобы реализовать декоратор с параметрами можно использовать разные подходы:
#   1. Реализация декоратора через функцию
#   2. Реализация декоратора через класс

# Реализуем декоратор, который будет замедлять выполнение декорируемой функции

from functools import wraps
import time

# ---- Декоратор с параметрами, реализованный через функцию ----

def sleep(timeout):             # <- Самая внешняя функция будет принимать параметр
                                # и создавать декоратор ("Фабрика")

    def decorator(func):        # <- Сам декоратор устроен обычным образом
        @wraps(func)
        def decorated(*args, **kwargs):
            ''' Декоратор sleep
            '''        
            t1 = time.sleep(timeout)            # <- Искусственный таймаут
            res = func(*args, **kwargs)     # <- Выполнить исходную функцию

            print('Function {} was sleeping'.format(func.__name__))

            return res          # <- Вернуть результат работы исходной функции

        return decorated        # <- Вернуть декорированную функцию

    return decorator            # <- Вернуть декоратор


@sleep(2)
def factorial(n):
    if n <= 1: 
        return 1
    else: 
        return n * factorial(n-1)


print(' -- Использован декоратор, реализованный через функцию --')
print('!!! Обратите внимание на то, сколько раз будет вызван декоратор (рекурсия) !!!')
print(factorial(5))
print()


# ---- Декоратор с параметрами, реализованный через класс ----

class Sleep():
    ''' Фабрика декораторов-замедлителей
    '''
    def __init__(self, timeout):
        self.timeout = timeout

    def __call__(self, func):
        ''' Декоратор-замедлитель
        '''        
        @wraps(func)
        def decorated(*args, **kwargs):
            ''' Декорированная функция
            '''
            time.sleep(self.timeout)
            res = func(*args, **kwargs)
            print('Function {} was sleeping in class'.format(func.__name__))
            return res
        return decorated  


                # Применение декоратора, основанного на классе, 
@Sleep(3)       # заключается в создании объекта данного класса
def factorial(n):
    if n <= 1: 
        return 1
    else: 
        return n * factorial(n-1)

print(' -- Использован декоратор, реализованный через класс --')
print('!!! Обратите внимание на то, сколько раз будет вызван декоратор (рекурсия) !!!')
print(factorial(5))

# Нужно внимательно отслеживать совместное использование рекурсивных функций и декораторов.
# Если применить декоратор к рекурсивной функции, 
# все внутренние рекурсивные вызовы будут обращаться к декорированной версии функции!!!
